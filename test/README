Run tests with::

  $ ./test/test.py

â€¦ from the root of the project.

Which looks for any ``*/feed.*`` files and processes them using each
``*.config`` file in the feed's directory.  The output messages are
saved (not mailed) and compared with the expected output for that
feed/config pair.  For example, with a directory structure like::

  test
  |-- README
  |-- allthingsrss
  |   |-- 1.config
  |   |-- 1.expected
  |   |-- 2.config
  |   |-- 2.expected
  |   `-- feed.atom
  |-- otherfeed
  |   |-- a.config
  |   |-- a.expected
  |   |-- b.config
  |   |-- b.expected
  |   `-- feed.rss
  `-- test.py

``test.py`` will parse:

* ``feed.atom`` after loading ``1.config`` and compare the output with
  ``1.expected``.
* ``feed.atom`` after loading ``2.config`` and compare the output with
  ``2.expected``.
* ``feed.rss`` after loading ``a.config`` and compare the output with
  ``a.expected``.
* ``feed.rss`` after loading ``b.config`` and compare the output with
  ``b.expected``.

Tests are run within Python's "unittest" framework
(https://docs.python.org/library/unittest.html), which means you can
do all the things that the unittest test driver does. For example, you
can:

* specify "-v" to list the individual tests as they are executing;
* specify one or more test classes to execute only the tests in those
  classes (look in test/test.py for the names of the test classes, or
  get them from the "-v" output); or
* specify one or more individual tests in the form TestClass.test_name
  to execute only those tests.
